package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class Arm extends SubsystemBase {
    /* Constants */
    public final int PID_CONFIG_TIMEOUT_MS = 10;
    public final int TALON_FX_CAN_ID = 6;
    public final int REACH_TALON_FX_CAN_ID = 7;
    public final int CONFIG_ARM_FEEDBACKSENSOR_TIMEOUT_MS = 4000;
    public final double SHOULDER_KF = 0.0d;
    public final double SHOULDER_KP = 0.0d;
    public final double SHOULDER_KI = 0.0d;
    public final double SHOULDER_KD = 0.0d;
    public final double MOTOR_NEUTRAL_DEADBAND = 0.001d;
    public final double PERIODIC_RUNS_PER_SECOND = 50.0d;
    public final double ARM_X_DELTA_MODIFIER = 6.0 / PERIODIC_RUNS_PER_SECOND;
    public final double ARM_Y_DELTA_MODIFIER = 6.0 / PERIODIC_RUNS_PER_SECOND;
    public final double ARM_SHOULDER_X_INCHES = 17.0d;
    public final double ARM_SHOULDER_Y_INCHES = 54.0d;
    public final double CALIBRATION_MOTOR_SPEED = 0.1;
    public final double SCORE_LOW_X_INCHES = 20.0d; // TODO: Low: Find the value for how far the extension motor has to extend in inches.  
    public final double SCORE_LOW_ANGLE = 42.0d;
    public final double SCORE_MID_X_INCHES = 40.0d; // TODO: Mid: Find the value for how far the extension motor has to extend in inches. 
    public final double SCORE_MID_ANGLE = 87.0d;
    public final double SCORE_HIGH_X_INCHES = 60.0; // TODO: High: Find the value for how far the extension motor has to extend in inches.
    public final double SCORE_HIGH_ANGLE = 106.0d;
    public final double SUBSTATION_PICKUP_ANGLE = 104.0d;
    public final double SUBSTATION_PICKUP_X_INCHES = 10.0d; // TODO: High: Find the value for how far the extension motor has to extend in inches.
    // Angles are in DEGREES
    public final double MIN_ANGLE = 0;
    public final double MAX_ANGLE = 110;
    // Arm shoulder Y inches is between pivot point and ground
    public final double ENCODER_UNITS_PER_REVOLUTION = 2048.0d;
    public final double SHOULDER_ENCODER_UNITS_PER_DEGREE = ENCODER_UNITS_PER_REVOLUTION / DEGREES_PER_REVOLUTION;
    public final double REACH_ENCODER_UNITS_PER_INCH = 5.0d; // NEED TO FIND THIS
    // Gear ratios
    public final double MOTOR_ROTATIONS_PER_ENCODER_UNIT = 1.0d / ENCODER_UNITS_PER_REVOLUTION;
    public final double SHOULDER_GEARBOX_RATIO = 1.0d / 100.0d;
    public final double PULLEY_RATIO = 1.0d;

    public final double REACH_KF = 0.0d;
    public final double REACH_KP = 0.0d;
    public final double REACH_KI = 0.0d;
    public final double REACH_KD = 0.0d;

    /* Members */
    private WPI_TalonFX shoulderTalonFX;
    private WPI_TalonFX reachTalonFX;
    private double x;
    private double y;

    public static final int SHOULDER_TALON_FX_CAN_ID = 6;
    public static final double POSITION_KF = 0.0d;
    public static final double POSITION_KP = 0.0d;
    public static final double POSITION_KI = 0.0d;
    public static final double POSITION_KD = 0.0d;
    public static final double DEGREES_PER_REVOLUTION = 360;
    // Gear ratios
    public Arm() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        shoulderTalonFX = new WPI_TalonFX(SHOULDER_TALON_FX_CAN_ID);
        reachTalonFX = new WPI_TalonFX(REACH_TALON_FX_CAN_ID);

        // Clears motor errors
        shoulderTalonFX.clearStickyFaults();
        reachTalonFX.clearStickyFaults();

        // Set factory defaults for onboard PID
        shoulderTalonFX.configFactoryDefault();
        reachTalonFX.configFactoryDefault();

        shoulderTalonFX.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor, 0,
                CONFIG_ARM_FEEDBACKSENSOR_TIMEOUT_MS);
        reachTalonFX.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor, 0,
                CONFIG_ARM_FEEDBACKSENSOR_TIMEOUT_MS);

        shoulderTalonFX.setInverted(false);
        shoulderTalonFX.setSensorPhase(false);
        reachTalonFX.setInverted(true);
        reachTalonFX.setSensorPhase(true);

        // Configure Position PID
        shoulderTalonFX.config_kF(0, POSITION_KF, PID_CONFIG_TIMEOUT_MS);
        shoulderTalonFX.config_kP(0, POSITION_KP, PID_CONFIG_TIMEOUT_MS);
        shoulderTalonFX.config_kI(0, POSITION_KI, PID_CONFIG_TIMEOUT_MS);
        shoulderTalonFX.config_IntegralZone(0, 1000);
        shoulderTalonFX.config_kD(0, POSITION_KD, PID_CONFIG_TIMEOUT_MS);

        reachTalonFX.config_kF(0, POSITION_KF, PID_CONFIG_TIMEOUT_MS);
        reachTalonFX.config_kP(0, POSITION_KP, PID_CONFIG_TIMEOUT_MS);
        reachTalonFX.config_kI(0, POSITION_KI, PID_CONFIG_TIMEOUT_MS);
        reachTalonFX.config_IntegralZone(0, 1000);
        reachTalonFX.config_kD(0, POSITION_KD, PID_CONFIG_TIMEOUT_MS);

        reachTalonFX.setNeutralMode(NeutralMode.Brake);
        shoulderTalonFX.setNeutralMode(NeutralMode.Brake);

        reachTalonFX.configNeutralDeadband(MOTOR_NEUTRAL_DEADBAND);
        shoulderTalonFX.configNeutralDeadband(MOTOR_NEUTRAL_DEADBAND);
    }

    @Override
    public void periodic() {
        moveToPosition(x,y);
    }

    /**
     * Rotate the arm to a specific angle.
     * @param angle - the angle in degrees
     */
    public void rotateTo(double angle) {
        angle = Math.max(Math.min(angle, MAX_ANGLE), MIN_ANGLE);
        double encoderUnits = angle * SHOULDER_ENCODER_UNITS_PER_DEGREE;
        shoulderTalonFX.set(TalonFXControlMode.Position, encoderUnits);
    }

    /**
     * Extends arm to a given amount of inches.
     * @param length - the length to extend/retract to in inches
     */
    public void extendTo(double length) {
        double encoderUnits = length * REACH_ENCODER_UNITS_PER_INCH;
        reachTalonFX.set(TalonFXControlMode.Position, encoderUnits);
    }

    /**
     * Moves the arm to a given position in space relative to the base.
     * 
     * @param targetX - position in inches
     * @param targetY - position in inches
     */
    public void moveToPosition(double targetX, double targetY) {
        double xDist = targetX - ARM_SHOULDER_X_INCHES;
        double yDist = targetY - ARM_SHOULDER_Y_INCHES;
        double length = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));
        double theta = Math.atan2(yDist, xDist);

        rotateTo(theta);
        extendTo(length);
    }

    /**
     * Sets the internal position of the arm.
     * @param xPos - position in inches
     * @param yPos - position in inches
     */
    public void setPosition(double xPos, double yPos) {
        x = xPos;
        y = yPos;
    }

    public void adjustPosition(double xPercentage, double yPercentage) {
        x += ARM_X_DELTA_MODIFIER * xPercentage;
        y += ARM_Y_DELTA_MODIFIER * yPercentage;
    }

    public double encoderToDegrees(double encoderUnits) {
        return encoderUnits / ENCODER_UNITS_PER_REVOLUTION * DEGREES_PER_REVOLUTION;
    }

    public void shoulderZero() {
        shoulderTalonFX.setSelectedSensorPosition(0);
    }
    
    public void reachZero() {
        reachTalonFX.setSelectedSensorPosition(0);
    }

    public void startShulderCalibration() {
        shoulderTalonFX.set(-CALIBRATION_MOTOR_SPEED);
    }

    public void startReachCalibration(){
        reachTalonFX.set(-CALIBRATION_MOTOR_SPEED);
    }

    public boolean checkCalibration() {
        boolean done = true;
        if (shoulderTalonFX.isRevLimitSwitchClosed() == 1) {
            shoulderTalonFX.set(0);
        } else {
            done = false;
        }
        if (reachTalonFX.isRevLimitSwitchClosed() == 1) {
            reachTalonFX.set(0);
        } else {
            done = false;
        }
        return done;
    }
}
